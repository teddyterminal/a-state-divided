<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script src="d3/d3.min.js"></script>
<style type="text/css">

/* On mouse hover, lighten state color */
path:hover {
  fill-opacity: .7;
}

/* Style for Custom Tooltip */
div.tooltip {   
  position: absolute;           
  text-align: center;           
  width: 60px;                  
  height: 28px;                 
  padding: 2px;             
  font: 12px sans-serif;        
  background: white;   
  border: 0px;      
  border-radius: 8px;           
  pointer-events: none;         
}
        
/* Legend Font Style */
body {
  font: 11px sans-serif;
}
        
/* Legend Position Style */
.legend {
  position:absolute;
  left:800px;
  top:350px;
}

</style>
</head>
<body bgcolor = "#AAAAAA">
<font size = '75px'> <center> <strong> A State, Divided </strong> </center> </font>  
<div id = "usmap" align = "center"></div>  
<br/> 
<div id = "uslegend" align = "center"></div>   


<font size = "6" color = "FFFF00"> <strong> <center> gerrymandering. </strong> </font> </center>
<font align = "center" size = "4"> <center> In today's political climate, that word means a lot to us. And yet what is it, exactly? Is it a <font size = "5"> <strong> political tactic?</strong> </font> A method of <font size = "5"> <strong> voter suppression?</strong> </font> Surely yes, but what does that mean for affected communities? When a politician seeks to gerrymander a state, they do so by making one of <font size = "5"> <strong> quintillions </strong> </font> of possible cuts one can make to partition a state into equal-sized pieces. So how do they choose? And how should we? </center> </font>

<br/> <br/> 

<font align = "center" size = "4"> <center> Researchers at the Metric Geometry and Gerrymandering Group have begun to understand the scope of the <font size = "5"> <strong> space </strong> </font> of all of these possible plans. It is a huge landscape, with more orientations for districts than we could ever imagine. Yet through Markov Chain Monte Carlo <font size = "5"> <strong> (MCMC) </strong> </font> sampling, we can at least start to explore this wildnerness. </center> </font>
<br/> <br/> 
<font align = "center" size = "4"> <center> The principle, in its intuition, is fairly simple. Given a districting plan, we propose a modification. If that modification passes muster, we have a new plan. These changes are <font size = "5"> <strong> random, </strong> </font> but carefully calculated such that we have a real chance at obtaining a representative sample of this space of plans. </center></font>
<br/> <br/> 
<font align = "center" size = "4"> <center> So what do these plans look like? How do they affect people living in the state? Research doesn't tend to look at this - the primary aim is to calculate summaries in order to detect instances of gerrymandering. But we have taken a different approach, looking to show <font size = "5"> <strong> for the first time </strong> </font> what these entirely statistically generated plans look like. In how many ways can we define "community"? Soon, we will find out.  </center></font>

<br/> <br/> <font align = "center" size = "4"> <center>  Click on Iowa, Pennsylvania, or Georgia to begin. </center></font>

<br/> <br/> Click <a href = "Final Paper.pdf"> here </a> to read the paper associated with this project. Special thanks should go to Arvind Satyanarayan, professor of 6.894 for this term, for advice on how to proceed given the extremely tight schedule and the nature of a single-person team. Also thanks to Soya Park, the teaching assistant for this term, for her guidance. Finally thanks should be given to Daryl Deford, Postdoctoral Associate at MGGG and the supervisor to the author, and Justin Solomon, professor and PI for MGGG. <br/> 

<center> <iframe width="560" height="315" src="https://www.youtube.com/embed/SGclzpQB_AQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> </center>

<br/><br/> <br/> <font size = "1"> <center> Copyright © 2019 Rishabh Chandra </center> </font>
<center>

<script type="text/javascript">

/*  This visualization was made possible by modifying code provided by:

Michelle Chandra: http://bl.ocks.org/michellechandra/0b2ce4923dc9b5809922

Scott Murray, Choropleth example from "Interactive Data Visualization for the Web" 
https://github.com/alignedleft/d3-book/blob/master/chapter_12/05_choropleth.html   
    
Malcolm Maclean, tooltips example tutorial
http://www.d3noob.org/2013/01/adding-tooltips-to-d3js-graph.html

Mike Bostock, Pie Chart Legend
http://bl.ocks.org/mbostock/3888852  */

    
//Width and height of map
var width = 960;
var height = 500;

// D3 Projection
var projection = d3.geoAlbersUsa()
           .translate([width/2, height/2])    // translate to center of screen
           .scale([1000]);          // scale things down so see entire US
        
// Define path generator
var path = d3.geoPath()               // path generator that will convert GeoJSON to SVG paths
         .projection(projection);  // tell path generator to use albersUsa projection

    
// Define linear scale for output
var color = d3.scaleLinear()
        .range(["rgb(213,222,217)", "rgb(250,240,255)","rgb(200,180,200)", "rgb(75,50,150)" ]);

var legendText = ["Districts Available", "Shapefile In Progress", "1 Congressional District", "Districts Not Available"];

//Create SVG element and append map to the SVG
var svg = d3.select("#usmap")
      .append("svg")
      .attr("width", width)
      .attr("height", height);
        
// Append Div for tooltip to SVG
var div = d3.select("#usmap")
        .append("div")   
        .attr("class", "tooltip")               
        .style("opacity", 0);

d3.csv("availability.csv").then(async function(data) {
color.domain([0, 1, 2, 3]); // setting the range of the input data

var map = await d3.json("usa.json").then(async function(json){

// Loop through each state data value in the .csv file
for (var i = 0; i < data.length; i++) {

  // Grab State Name
  var dataState = data[i].state;

  // Grab data value 
  var dataValue = data[i].visited;

  // Find the corresponding state inside the GeoJSON
  for (var j = 0; j < json.features.length; j++)  {
    var jsonState = json.features[j].properties.name;

    if (dataState == jsonState) {

    // Copy the data value into the JSON
    json.features[j].properties.visited = dataValue; 

    // Stop looking through the JSON
    break;
    }
  }
}
    
// Bind the data to the SVG and create one path per GeoJSON feature
svg.selectAll("path")
  .data(json.features)
  .enter()
  .append("path")
  .attr("d", path)
  .style("stroke", "#fff")
  .style("stroke-width", "1")
  .style("fill", function(d) {

  // Get data value
  var value = d.properties.visited;

  if (value) {
  //If value exists…
  return color(value);
  } else {
  //If value is undefined…
  return "rgb(213,222,217)";
  }
})
  .on("click", function(d)
    {
      console.log(d)
      console.log(d.properties.name)
      var name = d.properties.name; 
      if (name == "Pennsylvania")
        window.location = 'pa.html'; 
      else if (name == "Georgia")
        window.location = 'ga.html'; 
      else if (name == "Iowa")
        window.location = 'ia.html'; 
    });


        
// Modified Legend Code from Mike Bostock: http://bl.ocks.org/mbostock/3888852
var legend = d3.select("#uslegend").append("svg")
          .attr("width", 140)
          .attr("height", 200)
          .selectAll("g")
          .data(color.domain().slice().reverse())
          .enter()
          .append("g")
          .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

    legend.append("rect")
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", color);

    legend.append("text")
        .data(legendText)
          .attr("x", 24)
          .attr("y", 9)
          .attr("dy", ".35em")
          .text(function(d) { return d; });

await d3.csv("nationalcities.csv").then(function(data) {

svg.selectAll("circle")
  .data(data)
  .enter()
  .append("circle")
  .attr("cx", function(d) {
    return projection([d.lon, d.lat])[0];
  })
  .attr("cy", function(d) 
  {
    return projection([d.lon, d.lat])[1];
  })
  .attr("r", 3)
  .style("fill", "#000000")
  .text(function(d){return d.place;});


svg.selectAll("text")
       .data(data)
       .enter()
       .append("text")
       // Add your code below this line
       .text((d) => d.place)
       .attr("x", function(d) {
          q = projection([d.lon, d.lat])[0];
          return q + 5
        })
       .attr("y",   function(d){
    return projection([d.lon, d.lat])[1];
  })
         })  


});





});


</script>

</body>
</html>

